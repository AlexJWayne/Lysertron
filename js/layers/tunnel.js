// Generated by CoffeeScript 1.3.3
(function() {
  var __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  Layers.Tunnel = (function(_super) {

    __extends(Tunnel, _super);

    Tunnel.prototype.uniformAttrs = {
      brightness: 'f',
      beatBrightness: 'f',
      ripples: 'fv1',
      ease: 'f',
      ringSize: 'f',
      baseColor: 'c'
    };

    function Tunnel() {
      Tunnel.__super__.constructor.apply(this, arguments);
      this.brightness = 1;
      this.beatBrightness = 1;
      this.ripples = [1];
      this.baseColor = new THREE.Color().setHSV(Math.random(), THREE.Math.randFloat(0.5, 1), THREE.Math.randFloat(0.5, 1));
      this.spin = THREE.Math.randFloatSpread(180) * Math.PI / 180;
      this.ease = THREE.Math.randFloat(2, 4);
      this.ringSize = THREE.Math.randFloat(0.1, 0.6);
      this.sides = Math.random() > 0.5 ? 40 : [3, 4, 5, 6, 7][THREE.Math.randInt(0, 4)];
      this.mesh = new THREE.Mesh(new THREE.CylinderGeometry(0, 1000, 20000, this.sides, 40), new THREE.ShaderMaterial(_.extend(this.getMatProperties('tunnel'), {
        side: THREE.BackSide,
        transparent: true,
        blending: THREE.AdditiveBlending
      })));
      this.mesh.material.side = THREE.BackSide;
      this.rotation.z = 90 * Math.PI / 180;
      this.add(this.mesh);
    }

    Tunnel.prototype.beat = function(beat) {
      this.beatBrightness = 1;
      this.ripples = this.ripples.slice(0, 3);
      return this.ripples.unshift(1);
    };

    Tunnel.prototype.bar = function(bar) {
      return this.brightness = 1;
    };

    Tunnel.prototype.update = function(elapsed) {
      var ripple;
      Tunnel.__super__.update.apply(this, arguments);
      this.ripples = (function() {
        var _i, _len, _ref, _results;
        _ref = this.ripples;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          ripple = _ref[_i];
          ripple -= 0.4 * elapsed;
          if (ripple > 0) {
            _results.push(ripple);
          } else {
            _results.push(0);
          }
        }
        return _results;
      }).call(this);
      this.beatBrightness -= 1.25 * elapsed;
      this.brightness -= 0.3 * elapsed;
      return this.mesh.rotation.y += this.spin * elapsed;
    };

    return Tunnel;

  })(Layers.Base);

}).call(this);
