{
  "name": "fermata",
  "version": "0.8.7",
  "homepage": "https://github.com/natevw/fermata",
  "repository": {
    "type": "git",
    "url": "https://github.com/natevw/fermata.git"
  },
  "author": {
    "name": "&yet, LLC",
    "url": "http://andyet.net"
  },
  "contributors": [
    {
      "name": "Nathan Vander Wilt",
      "email": "nate@calftrail.com",
      "url": "http://exts.ch"
    }
  ],
  "description": "Succinct native REST client, for client-side web apps and node.js. Turns URLs into magic JavaScript objects. Supports JSON, CouchDB, OAuth 1.0a, form uploads and more!",
  "licenses": [
    {
      "type": "MIT",
      "url": "https://github.com/natevw/fermata/raw/master/README.md"
    }
  ],
  "dependencies": {
    "node-proxy": "0.6.x"
  },
  "main": "fermata",
  "readme": "# Fermata #\n\nFermata is a JavaScript REST library that lets you simply state your HTTP requests using clean syntax.\n\nFeatures:\n\n* cleanly build URL strings (optional dot syntax — <i>node.js</i>, <i>supporting browsers</i>) and send asynchronous HTTP requests\n* automatic conversion of JSON request/response data\n* easily send raw data and form requests (including files!)\n* full customization of request (method, headers, data) when necessary\n* easy to add custom initialization and transport handlers\n* OAuth 1.0a support — <i>node.js</i>\n\nFermata is a no-hassle library, compatible with all modern browsers *and* node.js\n\n\n## Why? ##\n\nFermata magically provides a clean JavaScript interface for direct access to any REST interface.\n\nIt does this by taking away the pain of URL strings and giving back a polished server response.\nFermata works well in modern browsers and even better in [node.js](http://nodejs.org/).\nIts API naturally matches the authoritative HTTP documentation, so you always have access to each of your REST interfaces' latest and greatest features.\nThe simple plugin interface makes it easy to provide site-specific defaults, and/or support servers that don't use the standard JSON data format.\n\nThe differences are subtle, but the result is magic!\nIn the end, Fermata makes URLs so elegant that there is no need to use — or maintain! — some one-off \"wrapper library\" for every different service.\n\n\n## Magic? ##\n\nFor production apps you'll want this file on your own server, but for quick **in-browser** development you can simply include:\n\n    <script src=\"https://raw.github.com/natevw/fermata/master/fermata.js\"></script>\n\nThis will make Fermata available through a single global variable on the window: `fermata`\n\nTo make Fermata available under **node.js**, simply:\n\n    $ npm install fermata\n\nThe examples below assume you import Fermata's module via `var fermata = require('fermata');`\n\nAlrighty then?\n\n### Let's GET started ###\n\nSo you need to fetch a JSON resource from \"http://youraccount.example.com/api/v3/frobbles\"?\n\nIn Fermata, that's just:\n\n    var site = fermata.json(\"http://youraccount.example.com\");\n    site.api.v3.frobbles.get(function (err, result) {\n       if (!err) console.log(\"The first Frobble is named\", result[0].name);\n    });\n\n***Fermata turns even URLs themselves into native JavaScript objects!***\nEach path part becomes a property, and so slashes in HTTP paths simply turn into dot operators on JavaScript objects. When you pass a callback function, Fermata uses the last method call as the request's method.\nIt really couldn't *get* much cleaner.\n\nNeed to add query parameters?\n\n    var newAPI = site.api.v4;     // reuses the base URL from above\n    newAPI.frobbles({ perPage: 10, page: myPageNum }).get(myPageHandler);\n\nThis does a `GET` on `http://youraccount.example.com/api/v4/frobbles?perPage=10&page=N`, then asynchronously passes the response data to the `myPageHandler` callback function after automatically converting the raw JSON response text into a ready-to-use object.\n\n### Browser behind the times? ###\n\nUnfortunately, the examples above will only work in node.js, Firefox 4+ and ([soon](http://code.google.com/p/v8/issues/detail?id=1543)) Chrome. But don't worry!\nIn browsers without JavaScript's upcoming [Proxy](http://wiki.ecmascript.org/doku.php?id=harmony:proxies) feature you just need to use parentheses to form URLs, instead of dots:\n\n    var newAPI = site('api')('v4');\n    newAPI('frobbles')({ perPage: 10, page: myPageNum }).get(myPageHandler);\n\nNote how the dot syntax does still work for the final `.get`; Fermata provides fallbacks for the basic HTTP methods until browsers catch up.\n\nThere's no harm in always using parentheses — you'll need them for adding query parameters or avoiding path component escaping anyway. The following all return the same URL string:\n\n    site.api.v4['cannot-dot']({key:\"val\"})()      // requires harmony-proxies support\n    site(['api/v4'])('cannot-dot')({key:\"val\"})()\n    site(['api/v4', 'cannot-dot'])({key:\"val\"})()\n    site('api', 'v4', 'cannot-dot', {key:\"val\"})()\n\n\n\n### PUT ###\n\nOf course, it's also easy to *update* a REST resource with Fermata. Let's set some configuration on \"http://youraccount.example.com/api/v3/whoozits/&lt;ID&gt;/repertoire\":\n\n    (site.api.v3.whoozits[i].repertoire).put({\n        tricks: [1,2,3,4]\n    }, function (error, result) {\n        if (!error) {\n            console.log(\"Configuration accepted for Whoozit #\" + i);\n        } else {\n            console.warn(error);\n        }\n    });\n\n\nYou can send data by passing it to the request method before your callback function (and headers by passing them before the data, but plugins usually handle that for you...).\nJust like Fermata converts the server's raw response into a JavaScript object, Fermata can convert data dictionaries into a variety of raw formats for you: JSON, x-www-form-urlencoded, form-data...\n\n### POST ###\n\nWhen the HTTP documentation says something like, \"To create a Quibblelog, POST it to /utils/quibblelogger\":\n\n    site.utils.quibblelogger.post({ message: \"All your base.\", level: 'stern warning' }, someCallback);\n\nOr for cross-browser support:\n\n    site('utils')('quibblelogger').post({ message: \"All your base.\", level: 'stern warning' }, someCallback);\n\nVoilà!\n\n\n## Plugins ##\n\nEvery time you initialize a new Fermata URL, you do so through a plugin. Fermata provides two built-in (high level) plugins:\n\n1. `json` — initialized with a base URL string, then simply sends a JavaScript object to the server as a JSON string and expects that the server will reply with JSON too.\n2. `raw` - gives more direct access, whatever text/byte data you pass gets sent verbatim and your callback gets the full response info. This is a handy way to start when adding new plugins (see below).\n\nMany useful REST servers might talk in XML, or require that every request be specially signed with a secret key. Or maybe you just want to build the base URL string from higher-level settings.\n\nEnter custom plugins.\n\nFor example, many of the ideas in Fermata originated in a [node.js Chargify library](https://github.com/natevw/node-chargify) we wrote for their [payment management API](http://docs.chargify.com/api-introduction).\n\nWithout plugins, setting up Fermata to connect to Chargify is totally possible...but kinda ugly:\n\n    var acct = fermata.json({url:\"http://\" + api_key + \":x@\" + site_name + \".chargify.com\"});\n\nWith the old custom Chargify-specific library this was a lot cleaner:\n\n    var acct = chargify.wrapSite(site_name, api_key);\n\n...but of course if we stick with the old custom library, we then have to learn how to use its old custom interface (which was a bit confusing, and didn't support Fermata's dot syntax).\n\nPlugins give us the best of both worlds. Fermata's one magical native API, with useful service-specific smoke and mirrors hiding backstage:\n\n    var acct = fermata.chargify(site_name, api_key);\n    // WHOOHOO NOW WE ARE MONEY MAKING!!!\n\n\nThere's a tiny bit of setup to use plugins from node.js, since Fermata can't *actually* read your mind:\n\n    var f = require('fermata');\n    require('fermata-chargify').init(f, 'billing');     // installs Chargify plugin into our Fermata module, optionally with a custom name.\n    \n    f.billing(site_name, api_key);\n\nIn the browser, just include any plugins after the script tag for Fermata, and each plugin will be accessible through its default name.\n\nSince such a \"fermata-chargify\" plugin hasn't been published yet, we can just register its implementation directly:\n\n    fermata.registerPlugin('myChargify', function (transport, name, key) {\n        // setup our custom base URL\n        this.base = \"http://\" + key + \":x@\" + name + \".chargify.com\";\n\n        return function (request, callback) {\n            // we can make usage much cleaner by automatically appending this extension\n            request.path[request.path.length-1] += \".json\";\n            \n            // the rest is \"borrowed\" from the built-in JSON plugin\n            request.headers['Accept'] = \"application/json\";\n            request.headers['Content-Type'] = \"application/json\";\n            request.data = JSON.stringify(request.data);\n            transport(request, function (err, response) {\n                if (!err) {\n                    if (response.status.toFixed()[0] !== '2') { err = Error(\"Bad status code from server: \" + response.status); }\n                    try {\n                        response = JSON.parse(response.data);\n                    } catch (e) { err = e; }\n                }\n                callback(err, response);\n            });\n        };\n    });\n\nPlugin support is still young, and it might be nice to make it easier for plugins to build off of e.g. common JSON, OAuth, etc. foundations in the future.\nTake a look at the detailed documentation below for tips on publishing plugins that can be easily used from both node.js and the browser.\n\n\n## Complete documentation ##\n\n*NOTE*: this API may continue to [undergo refinement](https://github.com/natevw/fermata/blob/master/ROADMAP.md) until a stable 1.0 release.\n\n\n### URL proxy ###\n\n* `fermata.json(base_url)` - create a URL proxy object for base_url using the built-in 'json' plugin\n* `()` - absolute URL as string\n* `.method([headers, [data,]] function)` - request targetting callback\n* `(string/array...[, object])` - general extension syntax, each type documented below\n* `(object)` - override query parameters (see $key:value details below)\n* `(array)` - extend URL with components (without encoding)\n* `(string[, string...])` - extend URL (with encoding)\n* `[string]` - extend URL (with encoding)\n\nOnce you create a URL wrapper, you can extend it in various ways:\n\n    var api = fermata.json({url:\"http://api.example.com:5984\"});\n    var eg1 = api.database._design.app._view.by_date;\n    var eg2 = api['database']['_design']['app']['_view']['by_date'];\n    var eg3 = api(\"database\")(\"_design\")(\"app\")(\"_view\", \"by_date\");\n    var eg4 = api.database([\"_design/app\", \"_view/by_date\"]);\n\nThese all result in the same API endpoint. We can dump the URL as a string using an empty `()`:\n\n    eg1() === eg2() === eg3() === eg4() === \"http://api.example.com:5984/database/_design/app/_view/by_date\";\n\nAt any point in the process, you can set query parameters (a leading '$' on a key forces JSON stringification of the value):\n\n    var api = fermata.api({url:\"http://api.example.com:5984\", user:\"myuser\", password:\"mypassword\");\n    var faster_queries = api({ stale: 'ok' });\n    var always_include_docs = faster_queries.database({ include_docs: true });\n    var some_app = always_include_docs({ reduce: false })._design.app;\n    var recent_items = some_app(['_view/by_date'], { $endkey: [2011, 4, 1] });\n    recent_items({ limit: 10 })() === \"http://api.example.com:5984/database/_design/app/_view/by_date?stale=ok&include_docs=true&reduce=false&limit=10&endkey=%5B2011%2C4%2C1%5D\";\n\nThen, presto! To make a request on any Fermata URL, simply provide your response callback to the JavaScript method corresponding to the HTTP verb:\n    \n    api.database.get(logging_callback);\n    \n    var data = {};\n    api.database.put(data, logging_callback);\n    \n    var headers = {};\n    api.database.post(headers, data, logging_callback).post(data);\n    \n    // any method name can be used, not just the usual HTTP suspects\n    api.database.copy({Destination: \"new_database\"}, null, logging_callback);\n\n\n### Default plugins ###\n\nFermata provides two high-level plugins:\n\n* `fermata.json(\"http://example.com\")` - send/receive data objects as JSON\n* `fermata.raw({base:\"http://example.com\"})` - expects string request data, returns raw response from the platform-level transport, e.g. `yourCallback(null, {status:418 headers:{}, data:\"...\"})`\n\nThere are also several builtin plugins that are primarily intended for chaining within your own plugins:\n\n* `fermata.statusCheck()` - simple plugin that sets the callback error parameter if the response status code is not 2xx.\n* `fermata.autoConvert([defaultType])` - converts request/response data between native JS data objects and common HTTP content types, using header fields (currently supports: \"text/plain\", \"application/json\", \"application/x-www-form-urlencoded\", \"application/form-data\")\n* `fermata.oauth({client, client_secret[, token, token_secret]})` - adds an OAuth authorization signature to the requests it transports\n\n#### File handling ####\n\nThere are two primary ways a server might allow binary file uploads, and Fermata supports them both:\n\n* RESTful PUT - `fermata.raw(\"http://example.com/some/destination\").put(  nodeBufferOrBrowserFile  , callback)`\n* form upload - `fermata.json(\"http://example.com/some/action\").post({'Content-Type':\"multipart/form-data\"}, {fileField:  form.input.file || {data:nodeBuffer, name:\"\", type:\"\"}  }, callback)`\n\nFor multipart/form-data, send a File/Blob in the browser (Fermata will use the XHR2 FormData to send it). Under node.js, set the field name's value to an object with a `.data` property (and optional `.name` and `.type`). \n\nKeep in mind that Fermata is intentionally designed to convert back and forth between *fully-formed* HTTP data and *in-memory* JavaScript objects, as this is exactly what you want for API communication, documents and photos. For larger files like video data or disk snapshots, you'll want to directly use the streaming features of node.js on the server-side, and provide an interruptible uploader app on the client-side.\n\n\n### Adding plugins ###\n\n* `fermata.registerPlugin(name, setupFunction)` - register a plugin initialization function that receives the platform transport function. This function should set this.base and must return a (typically wrapped/extended) transport function.\n\nWhen the user calls `fermata.yourplugin(...)` to create a new URL wrapper, Fermata sets up a base \"transport\" function for your plugin to use and calls `yourSetupFunction(transport, ...)` with a `this` object set to an empty \"internal URL\" dictionary.\nYou can *chain* plugins with the `.using(name, ...)` method on the transport object you receive. For example, if you want your requests to be processed by  \nThe \"internal URL\" contains a subset of the request parameters (`{base:\"\", path:[\"\"], query:{}}`) that the user will be extending through Fermata's API. You can add defaults in your setup function, setting `this.base` to a specific service's API root for example.\n\nFermata plugins intended for cross-platform use should generally try to follow the following template:\n\n    var fermata;\n    (function () {\n        var plugin = function (transport, baseURL) {                // A plugin is a setup function which receives a base \"raw\" HTTP transport, followed by each argument supplied to the fermata.plugin call.\n            this.base = baseURL;\t\t\t\t    // ...this setup function can set default base/path/query items, then must return the (typically wrapped) request transport function.\n            transport = transport.using('statusCheck').using('autoConvert', \"application/json\");\t\t// any registered plugin may be used\n            return function (request, callback) {                   // request = {base, method, path, query, headers, data}\n                request.path[request.path.length - 1] += \".json\";   // NOTE: automatically adding an extension like this breaks the URL string Fermata automatically returns on `()` calls, and so this pattern will likely need to be replaced somehow before v1.0\n                transport(request, function (err, response) {       // response = {status, headers, data}\n                    callback(err, response);\n                });\n            };\n        };\n        \n        // some boilerplate to deal with browser vs. CommonJS\n        if (fermata) {\n            fermata.registerPlugin(\"jsonExtension\", plugin);\n        } else {\n            module.exports = plugin;\n        }\n    })();\n\nAs of Fermata v0.8, this plugin API may still need some improvement (=change) but the basic idea is that Fermata can easily delegate the interesting high-level decisions to logic customized for a particular REST server interface.\n\n\n## Release Notes ##\n\n* 0.1 - initial release\n* 0.2 - Better docs, API tweaks\n* 0.3 - URL.method() redesign\n* 0.5 - Browser support\n* 0.6 - Plugin architecture\n* 0.7 - Plugin chaining\n* 0.8 - Form-based file uploads\n\n## Roadmap ##\n\n* 0.9 - Clean up some loose ends and lingering \n* 1.0 - [Your feedback needed](https://github.com/natevw/fermata/issues) before the API is finalized!\n\n## License ##\n\nWritten by [Nathan Vander Wilt](http://twitter.com/natevw).\nCopyright © 2011 &yet, LLC. Released under the terms of the MIT License:\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.",
  "readmeFilename": "README.md",
  "_id": "fermata@0.8.7",
  "_from": "fermata@"
}
